import EventEmitter from "./Emitter";
import PriorityMap, { IPriorityListMapApi } from "./PriorityMap";
export declare type AnyFunction = (...args: any[]) => any;
export declare type Class<T> = Function & {
    prototype: T;
};
export declare type EventDefinition<EVENTS, EVENT extends keyof EVENTS> = Extract<EVENTS[EVENT], (...args: any[]) => any>;
export declare type EventParameters<EVENTS, EVENT extends keyof EVENTS = keyof EVENTS> = Parameters<EventDefinition<EVENTS, EVENT>>;
export declare type EventReturn<EVENTS, EVENT extends keyof EVENTS = keyof EVENTS> = ReturnType<EventDefinition<EVENTS, EVENT>>;
export declare type EventHandler<HOST, EVENTS, EVENT extends keyof EVENTS = keyof EVENTS> = (api: IEventApi<HOST, EVENTS, EVENT>, ...parameters: EventParameters<EVENTS, EVENT>) => EventReturn<EVENTS, EVENT>;
export declare type EventHandlerReference<HOST, EVENTS, EVENT extends keyof EVENTS = keyof EVENTS, SUBSCRIBER extends {
    [key in HANDLER]: EventHandler<HOST, EVENTS, EVENT>;
} = any, HANDLER extends keyof SUBSCRIBER = keyof SUBSCRIBER> = {
    [key in HANDLER]: Set<SUBSCRIBER>;
};
export interface IEventHandlersByType<HOST, EVENTS, EVENT extends keyof EVENTS = keyof EVENTS> {
    handlers: Set<EventHandler<HOST, EVENTS, EVENT>>;
    references: EventHandlerReference<HOST, EVENTS, EVENT>;
}
export declare type EventHandlersByPriority<HOST, EVENTS, EVENT extends keyof EVENTS = keyof EVENTS> = PriorityMap<IEventHandlersByType<HOST, EVENTS, EVENT>>;
export declare type EventList<EVENTS> = (keyof EVENTS) | (keyof EVENTS)[];
export declare type EventUnion<EVENTS, EVENT extends EventList<EVENTS>> = EVENT extends any[] ? EVENT[number] : EVENT;
export declare type EventSubscriptions<HOST, EVENTS> = {
    [EVENT in keyof EVENTS]?: EventHandlersByPriority<HOST, EVENTS, EVENT>;
};
export declare namespace EventSubscriptions {
    function get<HOST, EVENTS, EVENT extends keyof EVENTS>(subscriptions: EventSubscriptions<HOST, EVENTS>, event: EVENT): EventHandlersByPriority<HOST, EVENTS, EventUnion<EVENTS, EVENT>>;
    function get<HOST, EVENTS, EVENT extends keyof EVENTS>(subscriptions: EventSubscriptions<HOST, EVENTS>, event: EVENT, create: false): EventHandlersByPriority<HOST, EVENTS, EventUnion<EVENTS, EVENT>> | undefined;
    function getPriority<HOST, EVENTS, EVENT extends keyof EVENTS>(handlers: EventHandlersByPriority<HOST, EVENTS, EventUnion<EVENTS, EVENT>>, priority: number): IEventHandlersByType<HOST, EVENTS, EventUnion<EVENTS, EVENT>>;
}
export interface IEventApi<HOST, EVENTS = Events<HOST>, EVENT extends keyof EVENTS = keyof EVENTS> extends IPriorityListMapApi {
    readonly host: HOST;
    readonly event: EVENT;
    readonly index: number;
    /**
     * Whether the event should stop executing handlers after this handler
     */
    break: boolean;
    /**
     * Whether the return of this event handler should be disregarded in the event's results
     */
    disregard: boolean;
}
export declare const SYMBOL_SUBSCRIPTIONS: unique symbol;
export declare const SYMBOL_SUBSCRIPTIONS_SET_CLASS: unique symbol;
export declare const SYMBOL_EVENT_BUS_SUBSCRIPTIONS: unique symbol;
export interface IEventHost<EVENTS> {
    event: EventEmitter<this, EVENTS>;
}
export declare type EventHostOrClass<EVENTS> = IEventHost<EVENTS> | Class<IEventHost<EVENTS>>;
declare type EventsOfHostOrClass<HOST> = HOST extends EventHostOrClass<infer EVENTS> ? EVENTS : never;
export declare type EventBusOrHost<BUSES> = keyof BUSES | EventHostOrClass<EventsOfHostOrClass<BUSES[keyof BUSES]>>;
export declare type Host<HOST, BUSES = null> = HOST extends keyof BUSES ? BUSES[HOST] : HOST;
export declare type Events<HOST, BUSES = null> = EventsOfHostOrClass<Host<HOST, BUSES>>;
export declare type HostInstance<HOST> = HOST extends Class<infer INSTANCE> ? INSTANCE : HOST;
export interface IEventHostInternal<EVENTS> {
    [SYMBOL_SUBSCRIPTIONS]: EventSubscriptions<any, EVENTS>;
    [SYMBOL_SUBSCRIPTIONS_SET_CLASS]: any;
    [SYMBOL_EVENT_BUS_SUBSCRIPTIONS]: Record<string | number, EventSubscriptions<any, EVENTS>>;
}
export declare namespace IEventHostInternal {
    function getSubscriptions<EVENTS>(host: any): EventSubscriptions<any, EVENTS>[];
    function getHost<EVENTS>(host: any): IEventHostInternal<EVENTS>;
}
export declare const SYMBOL_SUBSCRIPTION_PROPERTY_REGISTRATIONS: unique symbol;
export declare const SYMBOL_SUBSCRIPTION_REGISTRATIONS: unique symbol;
export declare const SYMBOL_SUBSCRIBER_SET_CLASS: unique symbol;
export declare const SYMBOL_SUBSCRIBER_INSTANCES: unique symbol;
export declare type EventSubscriptionRegistrations<EVENTS> = {
    [EVENT in keyof EVENTS]?: Set<number>;
};
export declare type EventSubscriptionRegistrationsByHost = Map<any, EventSubscriptionRegistrations<any>>;
export declare type EventSubscriptionRegistrationsByProperty = Record<string, EventSubscriptionRegistrationsByHost>;
export declare type EventSubscriptionHandlerRegistrations = Map<any, EventSubscriptions<any, any>>;
export interface IEventSubscriber {
    [SYMBOL_SUBSCRIPTION_PROPERTY_REGISTRATIONS]?: EventSubscriptionRegistrationsByProperty;
    [SYMBOL_SUBSCRIPTION_REGISTRATIONS]?: EventSubscriptionHandlerRegistrations;
    [SYMBOL_SUBSCRIBER_SET_CLASS]?: any;
    [SYMBOL_SUBSCRIBER_INSTANCES]?: Set<any>;
}
export declare namespace IEventSubscriber {
    function getRegisteredPropertySubscriptions(cls: any): EventSubscriptionRegistrationsByProperty[];
    function getRegisteredSubscriptions(cls: any): EventSubscriptionHandlerRegistrations[];
    function getSubscriber(subscriber: any): IEventSubscriber;
    function addInstance(subscriber: IEventSubscriber, instance: any): boolean;
    function removeInstance(subscriber: IEventSubscriber, instance: any): boolean;
}
export declare type ReturnTypeLenient<F extends AnyFunction> = ReturnType<F> extends void ? Promise<void> : ReturnType<F>;
export declare type TypedPropertyDescriptorFunctionAnyNOfParams<F extends AnyFunction> = FunctionAnyNOfParams<Parameters<F>, ReturnTypeLenient<F>, ReturnType<F>>;
export declare type FunctionAnyNOfParams<PARAMS extends any[], RETURN_LENIENT, RETURN> = TypedPropertyDescriptor<(...args: PARAMS) => RETURN_LENIENT> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4], a5: PARAMS[5], a6: PARAMS[6], a7: PARAMS[7], a8: PARAMS[8], a9: PARAMS[9]) => RETURN_LENIENT> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4], a5: PARAMS[5], a6: PARAMS[6], a7: PARAMS[7], a8: PARAMS[8]) => RETURN_LENIENT> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4], a5: PARAMS[5], a6: PARAMS[6], a7: PARAMS[7]) => RETURN_LENIENT> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4], a5: PARAMS[5], a6: PARAMS[6]) => RETURN_LENIENT> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4], a5: PARAMS[5]) => RETURN_LENIENT> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4]) => RETURN_LENIENT> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3]) => RETURN_LENIENT> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2]) => RETURN_LENIENT> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1]) => RETURN_LENIENT> | TypedPropertyDescriptor<(a0: PARAMS[0]) => RETURN_LENIENT> | TypedPropertyDescriptor<() => RETURN_LENIENT> | TypedPropertyDescriptor<(...args: PARAMS) => RETURN> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4], a5: PARAMS[5], a6: PARAMS[6], a7: PARAMS[7], a8: PARAMS[8], a9: PARAMS[9]) => RETURN> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4], a5: PARAMS[5], a6: PARAMS[6], a7: PARAMS[7], a8: PARAMS[8]) => RETURN> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4], a5: PARAMS[5], a6: PARAMS[6], a7: PARAMS[7]) => RETURN> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4], a5: PARAMS[5], a6: PARAMS[6]) => RETURN> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4], a5: PARAMS[5]) => RETURN> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3], a4: PARAMS[4]) => RETURN> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2], a3: PARAMS[3]) => RETURN> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1], a2: PARAMS[2]) => RETURN> | TypedPropertyDescriptor<(a0: PARAMS[0], a1: PARAMS[1]) => RETURN> | TypedPropertyDescriptor<(a0: PARAMS[0]) => RETURN> | TypedPropertyDescriptor<() => RETURN>;
export {};
